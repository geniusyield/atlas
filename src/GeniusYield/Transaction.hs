{-|
Module      : GeniusYield.Transaction
Description : Tools to build balanced transactions
Copyright   : (c) 2023 GYELD GMBH
License     : Apache 2.0
Maintainer  : support@geniusyield.co
Stability   : develop

Balancing algorithm.

Inputs:

    * Transaction inputs
    * Transaction outputs
    * Transaction minted value

Additionally:

    * Set of additional UTxOs which can be spent
    * Collateral UTxO
    * Change address

The algorithm should produce sets of inputs and outputs
such the total value is @input + minted = outputs@.

The algorithms used to select inputs & produce change outputs are defined in 'GeniusYield.Transaction.CoinSelection'.

Each output should be big enough
(contain enough ADA, 'Api.calculateMinimumUTxO').
Algorithm may adjust them to include additional value.

There are also transacton fees which should also be taken into account.
We over-approximate the fees, and let 'Api.makeTransactionBodyAutoBalance' balance fees.
(We can be more precise here, and only slightly over-approximate,
 but @cardano-api@ doesn't provide a handy helpers to fill in execution units).

We make the algorithm iterative over the fee over-approximation. In particular, we start off
with a small over-approximation, and if tx finalization fails, we increase it. The very first
success is returned. Any over approximation (above the actual required fees), leads to generation of change output (besides those generated by coin selection) by `Api.makeTransactionBodyAutoBalance`. This new change output may fail minimum ada requirement, in which case we iterate with increased fee approximate.

Collateral input is needed when scripts are executed,
i.e. transaction mints tokens or consumes script outputs.

See 'Api.evaluateTransactionBalance' and 'Api.makeTransactionBodyAutoBalance'
(this function balances ADA only and doesn't add inputs, i.e. it calculates the ADA change).

-}
module GeniusYield.Transaction (
    -- * Top level build interface
    GYBuildTxEnv (..),
    buildUnsignedTxBody,
    GYBuildTxError (..),
    GYCoinSelectionStrategy (..),
    -- * Balancing only
    balanceTxStep,
    finalizeGYBalancedTx,
    GYBalancingError (..),
    -- * Utility type
    GYTxInDetailed (..),
) where

import qualified Cardano.Api                           as Api
import qualified Cardano.Api.Shelley                   as Api
import qualified Cardano.Api.Shelley                   as Api.S
import           Cardano.Crypto.DSIGN                  (sizeSigDSIGN,
                                                        sizeVerKeyDSIGN)
import qualified Cardano.Ledger.Alonzo.Core            as AlonzoCore
import qualified Cardano.Ledger.Alonzo.Scripts         as AlonzoScripts
import qualified Cardano.Ledger.Alonzo.Tx              as AlonzoTx
import qualified Cardano.Ledger.Binary                 as CBOR
import qualified Cardano.Ledger.Binary.Crypto          as CBOR
import qualified Cardano.Ledger.Coin                   as Ledger
import           Cardano.Ledger.Core                   (EraTx (sizeTxF),
                                                        eraProtVerLow)
import           Cardano.Ledger.Crypto                 (Crypto (..))
import           Cardano.Ledger.Era                    (Era (..))
import           Cardano.Ledger.Keys.WitVKey           (WitVKey (..))
import qualified Cardano.Ledger.Shelley.API.Wallet     as Shelley
import           Cardano.Slotting.Time                 (SystemStart)
import           Control.Arrow                         ((&&&))
import           Control.Lens                          (view)
import           Control.Monad.Random
import           Control.Monad.Trans.Except            (runExceptT, throwE)
import qualified Data.ByteString.Lazy                  as LBS
import           Data.Either.Combinators               (maybeToRight)
import           Data.Foldable                         (Foldable (foldMap'),
                                                        for_)
import           Data.List                             (delete)
import qualified Data.Map                              as Map
import           Data.Maybe                            (fromJust)
import           Data.Ratio                            ((%))
import           Data.Semigroup                        (Sum (..))
import qualified Data.Set                              as Set
import           GeniusYield.Imports
import           GeniusYield.Transaction.CBOR
import           GeniusYield.Transaction.CoinSelection
import           GeniusYield.Transaction.Common
import           GeniusYield.Types
import           GeniusYield.Types.TxCert.Internal

-- | A container for various network parameters, and user wallet information, used by balancer.
data GYBuildTxEnv = GYBuildTxEnv
    { gyBTxEnvSystemStart    :: !SystemStart
    , gyBTxEnvEraHistory     :: !Api.EraHistory
    , gyBTxEnvProtocolParams :: !(AlonzoCore.PParams (Api.S.ShelleyLedgerEra Api.S.BabbageEra))
    , gyBTxEnvPools          :: !(Set Api.S.PoolId)
    , gyBTxEnvOwnUtxos       :: !GYUTxOs
    -- ^ own utxos available for use as _additional_ input
    , gyBTxEnvChangeAddr     :: !GYAddress
    , gyBTxEnvCollateral     :: !GYUTxO
    }

utxoFromTxInDetailed :: GYTxInDetailed v -> GYUTxO
utxoFromTxInDetailed (GYTxInDetailed (GYTxIn ref _witns) addr val d ms) = GYUTxO ref addr val d ms

-------------------------------------------------------------------------------
-- Top level wrappers around core balancing logic
-------------------------------------------------------------------------------

{- | This is the lovelace overshoot we start with; the balancer will try with bigger amounts if this one fails.

The overshoot is not only to cover fees, but also to cover min deposits for change output(s).
-}
extraLovelaceStart :: Natural
extraLovelaceStart = 1_000_000

{- | This is the extra lovelace ceiling, after which - random improve algo will no longer be tried.

Due to the way RandomImprove works, depending on wallet state - it may not be computationally efficient to use
it when the extraLovelace param has built up a lot. Falling back to largest first may be a better choice so as to not
time out.
-}
randImproveExtraLovelaceCeil :: Natural
randImproveExtraLovelaceCeil = 20_000_000

-- | Pure interface to build the transaction body given necessary information.
buildUnsignedTxBody :: forall m v.
           (HasCallStack, MonadRandom m)
        => GYBuildTxEnv
        -> GYCoinSelectionStrategy
        -> [GYTxInDetailed v]
        -> [GYTxOut v]
        -> GYUTxOs  -- ^ reference inputs
        -> Maybe (GYValue, [(GYMintScript v, GYRedeemer)])  -- ^ minted values
        -> [GYTxWdrl v]  -- ^ withdrawals
        -> [GYTxCert v]  -- ^ certificates
        -> Maybe GYSlot
        -> Maybe GYSlot
        -> Set GYPubKeyHash
        -> Maybe GYTxMetadata
        -> m (Either GYBuildTxError GYTxBody)
buildUnsignedTxBody env cstrat insOld outsOld refIns mmint wdrls certs lb ub signers mbTxMetadata = buildTxLoop cstrat extraLovelaceStart
  where
    step :: GYCoinSelectionStrategy -> Natural -> m (Either GYBuildTxError ([GYTxInDetailed v], GYUTxOs, [GYTxOut v]))
    step stepStrat = fmap (first GYBuildTxBalancingError) . balanceTxStep env mmint wdrls certs insOld outsOld stepStrat

    buildTxLoop :: GYCoinSelectionStrategy -> Natural -> m (Either GYBuildTxError GYTxBody)
    buildTxLoop stepStrat n
        -- Stop trying with RandomImprove if extra lovelace has hit the pre-determined ceiling.
        | stepStrat /= GYLargestFirstMultiAsset && n >= randImproveExtraLovelaceCeil = buildTxLoop GYLargestFirstMultiAsset n
        | otherwise = do
            res <- f stepStrat n
            case res of
                {- These errors generally indicate the input selection process selected less ada
                than necessary. Try again with double the extra lovelace amount -}
                Left (GYBuildTxBodyErrorAutoBalance Api.TxBodyErrorAdaBalanceNegative{}) -> buildTxLoop stepStrat (n * 2)
                Left (GYBuildTxBodyErrorAutoBalance Api.TxBodyErrorAdaBalanceTooSmall{}) -> buildTxLoop stepStrat (n * 2)
                -- @RandomImprove@ may result into many change outputs, where their minimum ada requirements might be unsatisfiable with available ada.
                Left (GYBuildTxBalancingError err@(GYBalancingErrorChangeShortFall _))         -> retryIfRandomImprove
                                                                                            stepStrat
                                                                                            n
                                                                                            (GYBuildTxBalancingError err)
                {- RandomImprove may end up selecting too many inputs to fit in the transaction.
                In this case, try with LargestFirst and dial back the extraLovelace param.
                -}
                Left (GYBuildTxExUnitsTooBig maxUnits currentUnits)                      -> retryIfRandomImprove
                                                                                            stepStrat
                                                                                            n
                                                                                            (GYBuildTxExUnitsTooBig maxUnits currentUnits)
                Left (GYBuildTxSizeTooBig maxPossibleSize currentSize)                   -> retryIfRandomImprove
                                                                                            stepStrat
                                                                                            n
                                                                                            (GYBuildTxSizeTooBig maxPossibleSize currentSize)
                Right x                                                                -> pure $ Right x
                {- The most common error here would be:
                - InsufficientFunds
                - Script validation failure
                - Tx not within validity range specified timeframe

                No need to try again for these.
                -}
                other                                                                  -> pure other

    f :: GYCoinSelectionStrategy -> Natural -> m (Either GYBuildTxError GYTxBody)
    f stepStrat pessimisticFee = do
        stepRes <- step stepStrat pessimisticFee
        pure $ stepRes >>= \(ins, collaterals, outs) ->
            finalizeGYBalancedTx
                env
                GYBalancedTx
                    { gybtxIns           = ins
                    , gybtxCollaterals   = collaterals
                    , gybtxOuts          = outs
                    , gybtxMint          = mmint
                    , gybtxWdrls         = wdrls
                    , gybtxCerts         = certs
                    , gybtxInvalidBefore = lb
                    , gybtxInvalidAfter  = ub
                    , gybtxSigners       = signers
                    , gybtxRefIns        = refIns
                    , gybtxMetadata      = mbTxMetadata
                    }
                (length outsOld)

    retryIfRandomImprove GYRandomImproveMultiAsset n _ = buildTxLoop GYLargestFirstMultiAsset (if n == extraLovelaceStart then extraLovelaceStart else n `div` 2)
    retryIfRandomImprove _ _ err                       = pure $ Left err

-------------------------------------------------------------------------------
-- Primary balancing logic
-------------------------------------------------------------------------------

{- | An independent "step" of the balancing algorithm.

This step is meant to be run with different 'extraLovelace' values. If the 'extraLovelace' amount
is too small, there will not be enough ada to pay for the final fees + min deposits, when finalizing
the tx with 'finalizeGYBalancedTx'. If such is the case, 'balanceTxStep' should be called again with a higher
'extraLovelace' amount.
-}
balanceTxStep :: (HasCallStack, MonadRandom m)
    => GYBuildTxEnv
    -> Maybe (GYValue, [(GYMintScript v, GYRedeemer)])  -- ^ minting
    -> [GYTxWdrl v]                                     -- ^ withdrawals
    -> [GYTxCert v]                                     -- ^ certificates
    -> [GYTxInDetailed v]                               -- ^ transaction inputs
    -> [GYTxOut v]                                      -- ^ transaction outputs
    -> GYCoinSelectionStrategy                          -- ^ Coin selection strategy to use
    -> Natural                                          -- ^ extra lovelace to look for on top of output value
    -> m (Either GYBalancingError ([GYTxInDetailed v], GYUTxOs, [GYTxOut v]))
balanceTxStep
    GYBuildTxEnv
        { gyBTxEnvProtocolParams = pp
        , gyBTxEnvOwnUtxos       = ownUtxos
        , gyBTxEnvChangeAddr     = changeAddr
        , gyBTxEnvCollateral     = collateral
        }
    mmint
    wdrls
    certs
    ins
    outs
    cstrat
    = let adjustedOuts = map (adjustTxOut (minimumUTxO pp)) outs
          valueMint       = maybe mempty fst mmint
          needsCollateral = valueMint /= mempty || any (isScriptWitness . gyTxInWitness . gyTxInDet) ins || any (isCertScriptWitness . gyTxCertWitness) certs || any (isWdrlScriptWitness . gyTxWdrlWitness) wdrls
          apiPP = Api.S.fromLedgerPParams Api.ShelleyBasedEraBabbage pp
          ppStakeAddressDeposit = Api.S.protocolParamStakeAddressDeposit apiPP
          (stakeCredDeregsAmt :: Natural, stakeCredRegsAmt :: Natural) = foldl' (\acc@(!accDeregs, !accRegs) (gyTxCertCertificate -> cert) -> case cert of
                  GYStakeAddressDeregistrationCertificate _ -> (accDeregs + 1, accRegs)
                  GYStakeAddressRegistrationCertificate _   -> (accDeregs, accRegs + 1)
                  _                                         -> acc) (0, 0) certs
          -- Extra ada is received from withdrawals and stake credential deregistration.
          adaSource =
            let wdrlsAda = getSum $ foldMap' (coerce . gyTxWdrlAmount) wdrls
                stakeCredDeregsAda = stakeCredDeregsAmt * fromIntegral ppStakeAddressDeposit
            in wdrlsAda + stakeCredDeregsAda
          -- Ada lost due to stake credential registration.
          adaSink = stakeCredRegsAmt * fromIntegral ppStakeAddressDeposit
          collaterals
            | needsCollateral = utxosFromUTxO collateral
            | otherwise       = mempty
      in \extraLovelace -> runExceptT $ do
            for_ adjustedOuts $ \txOut ->
                unless (valueNonNegative $ gyTxOutValue txOut)
                    . throwE $ GYBalancingErrorNonPositiveTxOut txOut
            (addIns, changeOuts) <- selectInputs
                GYCoinSelectionEnv
                    { existingInputs  = ins
                    , requiredOutputs = (gyTxOutAddress &&& gyTxOutValue) <$> adjustedOuts
                    , mintValue       = valueMint
                    , changeAddr      = changeAddr
                    , ownUtxos        = ownUtxos
                    , extraLovelace   = extraLovelace
                    , minimumUTxOF    =
                        fromInteger
                        . flip valueAssetClass GYLovelace
                          . gyTxOutValue
                            . adjustTxOut (minimumUTxO pp)
                    , maxValueSize    = fromMaybe
                                            (error "protocolParamMaxValueSize missing from protocol params")
                                            $ Api.S.protocolParamMaxValueSize apiPP
                    , adaSource = adaSource
                    , adaSink   = adaSink
                    }
                cstrat
            pure (ins ++ addIns, collaterals, adjustedOuts ++ changeOuts)
  where
    isScriptWitness GYTxInWitnessKey            = False
    isScriptWitness GYTxInWitnessScript{}       = True
    isScriptWitness GYTxInWitnessSimpleScript{} = False  -- Simple (native) scripts don't require collateral.
    isCertScriptWitness (Just GYTxCertWitnessScript{}) = True
    isCertScriptWitness _                              = False
    isWdrlScriptWitness GYTxWdrlWitnessScript{} = True
    isWdrlScriptWitness _                       = False

retColSup :: Api.BabbageEraOnwards Api.BabbageEra
retColSup = Api.BabbageEraOnwardsBabbage

finalizeGYBalancedTx :: GYBuildTxEnv -> GYBalancedTx v -> Int -> Either GYBuildTxError GYTxBody
finalizeGYBalancedTx
    GYBuildTxEnv
        { gyBTxEnvSystemStart    = ss
        , gyBTxEnvEraHistory     = eh
        , gyBTxEnvProtocolParams = pp
        , gyBTxEnvPools          = ps
        , gyBTxEnvChangeAddr     = changeAddr
        }
    GYBalancedTx
        { gybtxIns           = ins
        , gybtxCollaterals   = collaterals
        , gybtxOuts          = outs
        , gybtxMint          = mmint
        , gybtxWdrls         = wdrls
        , gybtxCerts         = certs
        , gybtxInvalidBefore = lb
        , gybtxInvalidAfter  = ub
        , gybtxSigners       = signers
        , gybtxRefIns        = utxosRefInputs
        , gybtxMetadata      = mbTxMetadata
        }
    = makeTransactionBodyAutoBalanceWrapper
        collaterals
        ss
        eh
        apiPP
        ps
        (utxosToApi utxos)
        body
        changeAddr
        unregisteredStakeCredsMap
        estimateKeyWitnesses
  where
    -- Over-estimate the number of key witnesses required for the transaction.
    -- We do not provide support for byron key witnesses in our estimate as @Api.makeTransactionBodyAutoBalance@ does not consider them, i.e., count of key witnesses returned here are considered as shelley key witnesses by cardano api.
    estimateKeyWitnesses :: Word = fromIntegral $ countUnique $
         mapMaybe (extractPaymentPkhFromAddress . utxoAddress) (utxosToList collaterals)
      <> [apkh | GYTxWdrl {gyTxWdrlWitness = GYTxWdrlWitnessKey, gyTxWdrlStakeAddress = saddr} <- wdrls, let sc = stakeAddressToCredential saddr, Just apkh <- [preferSCByKey sc]]
      <> [apkh | cert@GYTxCert {gyTxCertWitness = Just GYTxCertWitnessKey} <- certs, let sc = certificateToStakeCredential $ gyTxCertCertificate cert, Just apkh <- [preferSCByKey sc]]
      <> estimateKeyWitnessesFromInputs ins
      <> Set.toList signers
      where
        extractPaymentPkhFromAddress gyaddr = addressToPaymentCredential gyaddr >>= \case
            GYPaymentCredentialByKey pkh -> Just $ toPubKeyHash pkh
            GYPaymentCredentialByScript _ -> Nothing

        preferSCByKey (GYStakeCredentialByKey pkh) = Just $ toPubKeyHash pkh
        preferSCByKey _otherwise                   = Nothing

        countUnique :: Ord a => [a] -> Int
        countUnique = Set.size . Set.fromList

        estimateKeyWitnessesFromInputs txInDets =
          -- Count key witnesses.
          [apkh | txInDet@GYTxInDetailed {gyTxInDet = GYTxIn {gyTxInWitness = GYTxInWitnessKey}} <- txInDets, let gyaddr = gyTxInDetAddress txInDet, Just apkh <- [extractPaymentPkhFromAddress gyaddr]]
          ++
          -- Estimate key witnesses required by native scripts.
          map toPubKeyHash (Set.toList $ foldl' estimateKeyWitnessesFromNativeScripts mempty txInDets)
            where
              estimateKeyWitnessesFromNativeScripts acc (gyTxInWitness . gyTxInDet -> GYTxInWitnessSimpleScript gyInSS) =
                case gyInSS of
                  GYInSimpleScript s -> getTotalKeysInSimpleScript s <> acc
                  GYInReferenceSimpleScript _ s -> getTotalKeysInSimpleScript s <> acc
              estimateKeyWitnessesFromNativeScripts acc _ = acc

    inRefs :: Api.TxInsReference Api.BuildTx Api.BabbageEra
    inRefs = case inRefs' of
        [] -> Api.TxInsReferenceNone
        _  -> Api.TxInsReference Api.BabbageEraOnwardsBabbage inRefs'

    inRefs' :: [Api.TxIn]
    inRefs' = [ txOutRefToApi r | r <- utxosRefs utxosRefInputs ]

    -- utxos for inputs
    utxosIn :: GYUTxOs
    utxosIn = utxosFromList $ utxoFromTxInDetailed <$> ins

    -- Map to lookup information for various utxos.
    utxos :: GYUTxOs
    utxos = utxosIn <> utxosRefInputs <> collaterals

    outs' :: [Api.S.TxOut Api.S.CtxTx Api.S.BabbageEra]
    outs' = txOutToApi <$> outs

    ins' :: [(Api.TxIn, Api.BuildTxWith Api.BuildTx (Api.Witness Api.WitCtxTxIn Api.BabbageEra))]
    ins' = [ txInToApi (isInlineDatum $ gyTxInDetDatum i) (gyTxInDet i) |  i <- ins ]

    collaterals' :: Api.TxInsCollateral Api.BabbageEra
    collaterals' = case utxosRefs collaterals of
        []    -> Api.TxInsCollateralNone
        orefs -> Api.TxInsCollateral Api.AlonzoEraOnwardsBabbage $ txOutRefToApi <$> orefs

    -- will be filled by makeTransactionBodyAutoBalance
    fee :: Api.TxFee Api.BabbageEra
    fee = Api.TxFeeExplicit Api.ShelleyBasedEraBabbage $ Ledger.Coin 0

    lb' :: Api.TxValidityLowerBound Api.BabbageEra
    lb' = maybe
        Api.TxValidityNoLowerBound
        (Api.TxValidityLowerBound Api.AllegraEraOnwardsBabbage . slotToApi)
        lb

    ub' :: Api.TxValidityUpperBound Api.BabbageEra
    ub' = Api.TxValidityUpperBound Api.ShelleyBasedEraBabbage $ slotToApi <$> ub

    extra :: Api.TxExtraKeyWitnesses Api.BabbageEra
    extra = case toList signers of
        []   -> Api.TxExtraKeyWitnessesNone
        pkhs -> Api.TxExtraKeyWitnesses Api.AlonzoEraOnwardsBabbage $ pubKeyHashToApi <$> pkhs

    mint :: Api.TxMintValue Api.BuildTx Api.BabbageEra
    mint = case mmint of
        Nothing      -> Api.TxMintNone
        Just (v, xs) -> Api.TxMintValue Api.MaryEraOnwardsBabbage (valueToApi v) $ Api.BuildTxWith $ Map.fromList
            [ ( mintingPolicyApiIdFromWitness p
              , gyMintingScriptWitnessToApiPlutusSW p
                      (redeemerToApi r)
                      (Api.ExecutionUnits 0 0)
              )
            | (p, r) <- xs
            ]

    -- Putting `TxTotalCollateralNone` & `TxReturnCollateralNone` would have them appropriately calculated by `makeTransactionBodyAutoBalance` but then return collateral it generates is only for ada. To support multi-asset collateral input we therefore calculate correct values ourselves and put appropriate entries here to have `makeTransactionBodyAutoBalance` calculate appropriate overestimated fees.
    (dummyTotCol :: Api.TxTotalCollateral Api.BabbageEra, dummyRetCol :: Api.TxReturnCollateral Api.CtxTx Api.BabbageEra) =
      if mempty == collaterals then
        (Api.TxTotalCollateralNone, Api.TxReturnCollateralNone)
      else
        (
        -- Total collateral must be <= lovelaces available in collateral inputs.
          Api.TxTotalCollateral retColSup (Ledger.Coin $ fst $ valueSplitAda collateralTotalValue)
        -- Return collateral must be <= what is in collateral inputs.
        , Api.TxReturnCollateral retColSup $ txOutToApi $ GYTxOut changeAddr collateralTotalValue Nothing Nothing
        )
      where
        collateralTotalValue :: GYValue
        collateralTotalValue = foldMapUTxOs utxoValue collaterals

    txMetadata :: Api.TxMetadataInEra Api.BabbageEra
    txMetadata = maybe Api.TxMetadataNone toMetaInEra mbTxMetadata
      where
        toMetaInEra :: GYTxMetadata -> Api.TxMetadataInEra Api.BabbageEra
        toMetaInEra gymd = let md = txMetadataToApi gymd in
          if md == mempty then Api.TxMetadataNone else Api.TxMetadataInEra Api.ShelleyBasedEraBabbage md

    wdrls' :: Api.TxWithdrawals Api.BuildTx Api.BabbageEra
    wdrls' = if wdrls == mempty then Api.TxWithdrawalsNone else Api.TxWithdrawals Api.ShelleyBasedEraBabbage $ map txWdrlToApi wdrls

    certs' =
      if certs == mempty
        then Api.TxCertificatesNone
        else
          let apiCertsFromGY =
                foldl'
                  (\(accCerts, accWits) cert ->
                    let (apiCert, mapiWit) = txCertToApi cert
                        apiWit = maybe Map.empty (uncurry Map.singleton) mapiWit
                    in (apiCert : accCerts, accWits <> apiWit)
                  ) (mempty, mempty) certs
          in Api.TxCertificates Api.ShelleyBasedEraBabbage (reverse $ fst apiCertsFromGY) $ Api.BuildTxWith (snd apiCertsFromGY)

    apiPP = Api.S.fromLedgerPParams Api.ShelleyBasedEraBabbage pp

    ppStakeAddressDeposit = fromIntegral $ Api.S.protocolParamStakeAddressDeposit apiPP

    unregisteredStakeCredsMap = Map.fromList [ (stakeCredentialToApi sc, ppStakeAddressDeposit) | GYStakeAddressDeregistrationCertificate sc  <- map gyTxCertCertificate certs]

    body :: Api.TxBodyContent Api.BuildTx Api.BabbageEra
    body = Api.TxBodyContent
        ins'
        collaterals'
        inRefs
        outs'
        dummyTotCol
        dummyRetCol
        fee
        lb'
        ub'
        txMetadata
        Api.TxAuxScriptsNone
        extra
        (Api.BuildTxWith $ Just $ Api.S.LedgerProtocolParameters pp)
        wdrls'
        certs'
        Api.TxUpdateProposalNone
        mint
        Api.TxScriptValidityNone
        Nothing
        Nothing

{- | Wraps around 'Api.makeTransactionBodyAutoBalance' just to verify the final ex units and tx size are within limits.

If not checked, the returned txbody may fail during submission.
-}
makeTransactionBodyAutoBalanceWrapper :: GYUTxOs
                                      -> SystemStart
                                      -> Api.S.EraHistory
                                      -> Api.ProtocolParameters
                                      -> Set Api.S.PoolId
                                      -> Api.S.UTxO Api.S.BabbageEra
                                      -> Api.S.TxBodyContent Api.S.BuildTx Api.S.BabbageEra
                                      -> GYAddress
                                      -> Map.Map Api.StakeCredential Ledger.Coin
                                      -> Word
                                      -> Int
                                      -> Either GYBuildTxError GYTxBody
makeTransactionBodyAutoBalanceWrapper collaterals ss eh apiPP _ps utxos body changeAddr stakeDelegDeposits nkeys numSkeletonOuts = do
    let poolids = Set.empty -- TODO: This denotes the set of registered stake pools, that are being unregistered in this transaction.

    Api.ExecutionUnits
        { executionSteps  = maxSteps
        , executionMemory = maxMemory
        } <- maybeToRight GYBuildTxMissingMaxExUnitsParam $ Api.S.protocolParamMaxTxExUnits apiPP
    let maxTxSize = Api.S.protocolParamMaxTxSize apiPP
        changeAddrApi :: Api.S.AddressInEra Api.S.BabbageEra = addressToApi' changeAddr
        drepDelegDeposits = mempty -- TODO:

    ledgerPP <- first GYBuildTxPPConversionError $ Api.S.convertToLedgerProtocolParameters Api.ShelleyBasedEraBabbage apiPP

    -- First we obtain the calculated fees to correct for our collaterals.
    bodyBeforeCollUpdate@(Api.BalancedTxBody _ _ _ (Ledger.Coin feeOld)) <-
      first GYBuildTxBodyErrorAutoBalance $ Api.makeTransactionBodyAutoBalance
        Api.ShelleyBasedEraBabbage
        ss
        (Api.toLedgerEpochInfo eh)
        ledgerPP
        poolids
        stakeDelegDeposits
        drepDelegDeposits
        utxos
        body
        changeAddrApi
        (Just nkeys)

    -- We should call `makeTransactionBodyAutoBalance` again with updated values of collaterals so as to get slightly lower fee estimate.
    Api.BalancedTxBody txBodyContent txBody extraOut _ <- if collaterals == mempty then return bodyBeforeCollUpdate else

      let

        collateralTotalValue :: GYValue = foldMapUTxOs utxoValue collaterals
        collateralTotalLovelace :: Integer = fst $ valueSplitAda collateralTotalValue
        balanceNeeded :: Integer = ceiling $ (feeOld * toInteger (fromJust $ Api.S.protocolParamCollateralPercent apiPP)) % 100

      in do

        (txColl, collRet) <-
          if collateralTotalLovelace >= balanceNeeded then return
            (
              Api.TxTotalCollateral retColSup (Ledger.Coin balanceNeeded)
            , Api.TxReturnCollateral retColSup $ txOutToApi $ GYTxOut changeAddr (collateralTotalValue `valueMinus` valueFromLovelace balanceNeeded) Nothing Nothing

            )
          else Left $ GYBuildTxCollateralShortFall (fromInteger balanceNeeded) (fromInteger collateralTotalLovelace)

          -- In this case `makeTransactionBodyAutoBalance` doesn't return
          -- an error but instead returns `(Api.TxTotalCollateralNone, Api.TxReturnCollateralNone)`

        first GYBuildTxBodyErrorAutoBalance $ Api.makeTransactionBodyAutoBalance
          Api.ShelleyBasedEraBabbage
          ss
          (Api.toLedgerEpochInfo eh)
          ledgerPP
          poolids
          stakeDelegDeposits
          drepDelegDeposits
          utxos
          body {Api.txTotalCollateral = txColl, Api.txReturnCollateral = collRet}
          changeAddrApi
          (Just nkeys)

    let Api.S.ShelleyTx _ ltx = Api.Tx txBody []
        -- This sums up the ExUnits for all embedded Plutus Scripts anywhere in the transaction:
        AlonzoScripts.ExUnits
            { AlonzoScripts.exUnitsSteps = steps
            , AlonzoScripts.exUnitsMem   = mem
            } = AlonzoTx.totExUnits ltx
        txSize :: Natural =
          let
              -- This low level code is taken verbatim from here: https://github.com/IntersectMBO/cardano-ledger/blob/6db84a7b77e19af58feb2f45dfc50aa70435967b/eras/shelley/impl/src/Cardano/Ledger/Shelley/API/Wallet.hs#L475-L494, as this is what is referred by @cardano-api@ under the hood.
              -- This does not take into account the bootstrap (byron) witnesses.
              version = eraProtVerLow @ShelleyBasedBabbageEra
              sigSize = fromIntegral $ sizeSigDSIGN (Proxy @(DSIGN (EraCrypto ShelleyBasedBabbageEra)))
              dummySig =
                fromRight
                  (error "corrupt dummy signature")
                  ( CBOR.decodeFullDecoder
                      version
                      "dummy signature"
                      CBOR.decodeSignedDSIGN
                      (CBOR.serialize version $ LBS.replicate sigSize 0)
                  )
              vkeySize = fromIntegral $ sizeVerKeyDSIGN (Proxy @(DSIGN (EraCrypto ShelleyBasedBabbageEra)))
              dummyVKey w =
                let padding = LBS.replicate paddingSize 0
                    paddingSize = vkeySize - LBS.length sw
                    sw = CBOR.serialize version w
                    keyBytes = CBOR.serialize version $ padding <> sw
                in fromRight (error "corrupt dummy vkey") (CBOR.decodeFull version keyBytes)
          in fromInteger $ view sizeTxF $ Shelley.addKeyWitnesses ltx (Set.fromList [WitVKey (dummyVKey x) dummySig | x <- [1 .. nkeys]])
    -- See: Cardano.Ledger.Alonzo.Rules.validateExUnitsTooBigUTxO
    unless (steps <= maxSteps && mem <= maxMemory) $
        Left $ GYBuildTxExUnitsTooBig (maxSteps, maxMemory) (steps, mem)
    -- See: Cardano.Ledger.Shelley.Rules.validateMaxTxSizeUTxO
    unless (txSize <= maxTxSize) $
        Left (GYBuildTxSizeTooBig maxTxSize txSize)

    collapsedBody <- first GYBuildTxCollapseExtraOutError $ collapseExtraOut extraOut txBodyContent txBody numSkeletonOuts

    first GYBuildTxCborSimplificationError $ simplifyGYTxBodyCbor $ txBodyFromApi collapsedBody


{- | Collapses the extra out generated in the last step of tx building into
    another change output (If one exists)

    The amount of outputs that should not be modified is needed. In other words,
    the amount of outputs described in the GYSkeleton. It is assumed that these
    outputs are at the start of the txOuts list.
-}
collapseExtraOut
  :: Api.TxOut Api.S.CtxTx Api.S.BabbageEra
  -- ^ The extra output generated by @makeTransactionBodyAutoBalance@.
  -> Api.TxBodyContent Api.S.BuildTx Api.S.BabbageEra
  -- ^ The body content generated by @makeTransactionBodyAutoBalance@.
  -> Api.TxBody Api.S.BabbageEra
  -- ^ The body generated by @makeTransactionBodyAutoBalance@.
  -> Int
  -- ^ The number of skeleton outputs we don't want to touch.
  -> Either Api.S.TxBodyError (Api.TxBody Api.S.BabbageEra)
  -- ^ The updated body with the collapsed outputs
collapseExtraOut apiOut@(Api.TxOut _ outVal _ _) bodyContent@Api.TxBodyContent {txOuts} txBody numSkeletonOuts
 | Api.txOutValueToLovelace outVal == 0 = pure txBody
 | otherwise =
    case delete apiOut changeOuts of
        [] -> pure txBody
        ((Api.TxOut sOutAddr sOutVal sOutDat sOutRefScript) : remOuts) ->
          let

            nOutVal = Api.TxOutValueShelleyBased Api.ShelleyBasedEraBabbage
                        $ Api.toLedgerValue Api.MaryEraOnwardsBabbage
                        $ foldMap' Api.txOutValueToValue [sOutVal, outVal]

            -- nOut == new Out == The merging of both apiOut and sOut
            nOut = Api.TxOut sOutAddr nOutVal sOutDat sOutRefScript
            -- nOuts == new Outs == The new list of outputs
            nOuts = skeletonOuts ++ remOuts ++ [nOut]

          in
            Api.S.createAndValidateTransactionBody Api.ShelleyBasedEraBabbage
              $ bodyContent { Api.txOuts = nOuts }
  where
    (skeletonOuts, changeOuts) = splitAt numSkeletonOuts txOuts

type ShelleyBasedBabbageEra = Api.S.ShelleyLedgerEra Api.BabbageEra
